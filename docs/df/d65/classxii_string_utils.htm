<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>XIIEngine: xiiStringUtils Class Reference</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="../../XII-Logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">XIIEngine
   &#160;<span id="projectnumber">1.0.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "../../search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('../../',true,false,'search.htm','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('df/d65/classxii_string_utils.htm','../../'); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="../../d7/dd3/classxii_string_utils-members.htm">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">xiiStringUtils Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Helper functions to work with UTF-8 strings (which include pure ASCII strings)  
 <a href="../../df/d65/classxii_string_utils.htm#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="../../de/dde/_string_utils_8h_source.htm">StringUtils.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:af474cd805cbd076c00d508adacd057bd"><td class="memItemLeft" align="right" valign="top"><a id="af474cd805cbd076c00d508adacd057bd"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d65/classxii_string_utils.htm#af474cd805cbd076c00d508adacd057bd">XII_CHARACTER_FILTER</a> = bool(*)(xiiUInt32 uiChar)</td></tr>
<tr class="memdesc:af474cd805cbd076c00d508adacd057bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function Definition for a function that determines whether a (Utf32) character belongs to a certain category of characters. <br /></td></tr>
<tr class="separator:af474cd805cbd076c00d508adacd057bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:acccec6a034eabdffff7a31a2b8613fe0"><td class="memTemplParams" colspan="2"><a id="acccec6a034eabdffff7a31a2b8613fe0"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:acccec6a034eabdffff7a31a2b8613fe0"><td class="memTemplItemLeft" align="right" valign="top">constexpr XII_ALWAYS_INLINE bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>IsNullOrEmpty</b> (const T *pString)</td></tr>
<tr class="separator:acccec6a034eabdffff7a31a2b8613fe0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8ee4ae5d0ada748c020fafc5ddcfecd"><td class="memTemplParams" colspan="2"><a id="ae8ee4ae5d0ada748c020fafc5ddcfecd"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae8ee4ae5d0ada748c020fafc5ddcfecd"><td class="memTemplItemLeft" align="right" valign="top">XII_ALWAYS_INLINE bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>IsNullOrEmpty</b> (const T *pString, const T *pStringEnd)</td></tr>
<tr class="separator:ae8ee4ae5d0ada748c020fafc5ddcfecd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab652c25f4d4e0280d0e1476c25babd76"><td class="memTemplParams" colspan="2"><a id="ab652c25f4d4e0280d0e1476c25babd76"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab652c25f4d4e0280d0e1476c25babd76"><td class="memTemplItemLeft" align="right" valign="top">XII_ALWAYS_INLINE void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>UpdateStringEnd</b> (const T *pStringStart, const T *&amp;ref_pStringEnd)</td></tr>
<tr class="separator:ab652c25f4d4e0280d0e1476c25babd76"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:acb10982c595d5619ce53fdd89313202f"><td class="memTemplParams" colspan="2"><a id="acb10982c595d5619ce53fdd89313202f"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:acb10982c595d5619ce53fdd89313202f"><td class="memTemplItemLeft" align="right" valign="top">static constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../df/d65/classxii_string_utils.htm#acb10982c595d5619ce53fdd89313202f">IsNullOrEmpty</a> (const T *pString)</td></tr>
<tr class="memdesc:acb10982c595d5619ce53fdd89313202f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true, if the given string is a nullptr pointer or a string that immediately terminates with a '\0' character. <br /></td></tr>
<tr class="separator:acb10982c595d5619ce53fdd89313202f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae08945bfcd20a0a83b1387d12e9a64ba"><td class="memTemplParams" colspan="2"><a id="ae08945bfcd20a0a83b1387d12e9a64ba"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae08945bfcd20a0a83b1387d12e9a64ba"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../df/d65/classxii_string_utils.htm#ae08945bfcd20a0a83b1387d12e9a64ba">IsNullOrEmpty</a> (const T *pString, const T *pStringEnd)</td></tr>
<tr class="memdesc:ae08945bfcd20a0a83b1387d12e9a64ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true, if the given string is a nullptr pointer, is equal to its end or a string that immediately terminates with a '\0' character. <br /></td></tr>
<tr class="separator:ae08945bfcd20a0a83b1387d12e9a64ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98e19f956607e291a7972109ed9e577f"><td class="memTemplParams" colspan="2"><a id="a98e19f956607e291a7972109ed9e577f"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a98e19f956607e291a7972109ed9e577f"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../df/d65/classxii_string_utils.htm#a98e19f956607e291a7972109ed9e577f">UpdateStringEnd</a> (const T *pStringStart, const T *&amp;ref_pStringEnd)</td></tr>
<tr class="memdesc:a98e19f956607e291a7972109ed9e577f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recomputes the end pointer of a string (<em>szStringEnd</em>), if that is currently set to xiiMaxStringEnd. Otherwise does nothing. <br /></td></tr>
<tr class="separator:a98e19f956607e291a7972109ed9e577f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9de18eab321e420a8c5e42fbbe4703d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:af9de18eab321e420a8c5e42fbbe4703d"><td class="memTemplItemLeft" align="right" valign="top">static constexpr xiiUInt32&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../df/d65/classxii_string_utils.htm#af9de18eab321e420a8c5e42fbbe4703d">GetStringElementCount</a> (const T *pString)</td></tr>
<tr class="memdesc:af9de18eab321e420a8c5e42fbbe4703d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of elements of type T that the string contains, until it hits an element that is zero OR until it hits the end pointer.  <a href="../../df/d65/classxii_string_utils.htm#af9de18eab321e420a8c5e42fbbe4703d">More...</a><br /></td></tr>
<tr class="separator:af9de18eab321e420a8c5e42fbbe4703d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66dfed366a3dea54e5244aebbb086d77"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a66dfed366a3dea54e5244aebbb086d77"><td class="memTemplItemLeft" align="right" valign="top">static xiiUInt32&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../df/d65/classxii_string_utils.htm#a66dfed366a3dea54e5244aebbb086d77">GetStringElementCount</a> (const T *pString, const T *pStringEnd)</td></tr>
<tr class="memdesc:a66dfed366a3dea54e5244aebbb086d77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of elements of type T that the string contains, until it hits an element that is zero OR until it hits the end pointer.  <a href="../../df/d65/classxii_string_utils.htm#a66dfed366a3dea54e5244aebbb086d77">More...</a><br /></td></tr>
<tr class="separator:a66dfed366a3dea54e5244aebbb086d77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a660d4fb3b9d622789dc720402d13eb55"><td class="memItemLeft" align="right" valign="top"><a id="a660d4fb3b9d622789dc720402d13eb55"></a>
static xiiUInt32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d65/classxii_string_utils.htm#a660d4fb3b9d622789dc720402d13eb55">GetCharacterCount</a> (const char *szUtf8, const char *pStringEnd=<a class="el" href="../../de/d05/classxii_unicode_utils.htm#a660bf5a88b574b4be176332064e55fbe">xiiUnicodeUtils::GetMaxStringEnd</a>&lt; char &gt;())</td></tr>
<tr class="memdesc:a660d4fb3b9d622789dc720402d13eb55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of characters (not Bytes!) in a Utf8 string (excluding the zero terminator), until it hits zero or the end pointer. <br /></td></tr>
<tr class="separator:a660d4fb3b9d622789dc720402d13eb55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae40dee43f8cded5ed4ec6fb0dfec9eb1"><td class="memItemLeft" align="right" valign="top"><a id="ae40dee43f8cded5ed4ec6fb0dfec9eb1"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d65/classxii_string_utils.htm#ae40dee43f8cded5ed4ec6fb0dfec9eb1">GetCharacterAndElementCount</a> (const char *szUtf8, xiiUInt32 &amp;ref_uiCharacterCount, xiiUInt32 &amp;ref_uiElementCount, const char *pStringEnd=<a class="el" href="../../de/d05/classxii_unicode_utils.htm#a660bf5a88b574b4be176332064e55fbe">xiiUnicodeUtils::GetMaxStringEnd</a>&lt; char &gt;())</td></tr>
<tr class="memdesc:ae40dee43f8cded5ed4ec6fb0dfec9eb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns both the number of characters and the number of bytes in a Utf8 string, until it hits zero or the end pointer. <br /></td></tr>
<tr class="separator:ae40dee43f8cded5ed4ec6fb0dfec9eb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44289a040ea3318f4a776e5d8035cf5b"><td class="memItemLeft" align="right" valign="top">static xiiUInt32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d65/classxii_string_utils.htm#a44289a040ea3318f4a776e5d8035cf5b">Copy</a> (char *szDest, xiiUInt32 uiDstSize, const char *szSource, const char *pSourceEnd=<a class="el" href="../../de/d05/classxii_unicode_utils.htm#a660bf5a88b574b4be176332064e55fbe">xiiUnicodeUtils::GetMaxStringEnd</a>&lt; char &gt;())</td></tr>
<tr class="memdesc:a44289a040ea3318f4a776e5d8035cf5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the string from szSource into the given buffer, which can hold at least uiDstSize bytes.  <a href="../../df/d65/classxii_string_utils.htm#a44289a040ea3318f4a776e5d8035cf5b">More...</a><br /></td></tr>
<tr class="separator:a44289a040ea3318f4a776e5d8035cf5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21f81d8eeb22d68b218eaf0518d4a324"><td class="memItemLeft" align="right" valign="top">static xiiUInt32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d65/classxii_string_utils.htm#a21f81d8eeb22d68b218eaf0518d4a324">CopyN</a> (char *szDest, xiiUInt32 uiDstSize, const char *szSource, xiiUInt32 uiCharsToCopy, const char *pSourceEnd=<a class="el" href="../../de/d05/classxii_unicode_utils.htm#a660bf5a88b574b4be176332064e55fbe">xiiUnicodeUtils::GetMaxStringEnd</a>&lt; char &gt;())</td></tr>
<tr class="memdesc:a21f81d8eeb22d68b218eaf0518d4a324"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies up to uiCharsToCopy characters into the given buffer, which can hold at least uiDstSize bytes.  <a href="../../df/d65/classxii_string_utils.htm#a21f81d8eeb22d68b218eaf0518d4a324">More...</a><br /></td></tr>
<tr class="separator:a21f81d8eeb22d68b218eaf0518d4a324"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63fc9ccdb43cd73fa24259e4d22b5c9d"><td class="memItemLeft" align="right" valign="top"><a id="a63fc9ccdb43cd73fa24259e4d22b5c9d"></a>
static xiiUInt32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d65/classxii_string_utils.htm#a63fc9ccdb43cd73fa24259e4d22b5c9d">ToUpperChar</a> (xiiUInt32 uiChar)</td></tr>
<tr class="memdesc:a63fc9ccdb43cd73fa24259e4d22b5c9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the upper case code point for uiChar. <br /></td></tr>
<tr class="separator:a63fc9ccdb43cd73fa24259e4d22b5c9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6aa1935de9440b74e57242eedf87e72f"><td class="memItemLeft" align="right" valign="top"><a id="a6aa1935de9440b74e57242eedf87e72f"></a>
static xiiUInt32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d65/classxii_string_utils.htm#a6aa1935de9440b74e57242eedf87e72f">ToLowerChar</a> (xiiUInt32 uiChar)</td></tr>
<tr class="memdesc:a6aa1935de9440b74e57242eedf87e72f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the lower case code point for uiChar. <br /></td></tr>
<tr class="separator:a6aa1935de9440b74e57242eedf87e72f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1629e8f94dd9f959339891cb0d91b2f"><td class="memItemLeft" align="right" valign="top">static xiiUInt32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d65/classxii_string_utils.htm#ad1629e8f94dd9f959339891cb0d91b2f">ToUpperString</a> (char *szString, const char *pStringEnd=<a class="el" href="../../de/d05/classxii_unicode_utils.htm#a660bf5a88b574b4be176332064e55fbe">xiiUnicodeUtils::GetMaxStringEnd</a>&lt; char &gt;())</td></tr>
<tr class="memdesc:ad1629e8f94dd9f959339891cb0d91b2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a (UTF-8) string in-place to upper case.  <a href="../../df/d65/classxii_string_utils.htm#ad1629e8f94dd9f959339891cb0d91b2f">More...</a><br /></td></tr>
<tr class="separator:ad1629e8f94dd9f959339891cb0d91b2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a824224a0b78ee435790cc8d40bd9a777"><td class="memItemLeft" align="right" valign="top">static xiiUInt32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d65/classxii_string_utils.htm#a824224a0b78ee435790cc8d40bd9a777">ToLowerString</a> (char *szString, const char *pStringEnd=<a class="el" href="../../de/d05/classxii_unicode_utils.htm#a660bf5a88b574b4be176332064e55fbe">xiiUnicodeUtils::GetMaxStringEnd</a>&lt; char &gt;())</td></tr>
<tr class="memdesc:a824224a0b78ee435790cc8d40bd9a777"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a (UTF-8) string in-place to lower case.  <a href="../../df/d65/classxii_string_utils.htm#a824224a0b78ee435790cc8d40bd9a777">More...</a><br /></td></tr>
<tr class="separator:a824224a0b78ee435790cc8d40bd9a777"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bb1ecbe39d0c2d0a4e58866dbe3ae66"><td class="memItemLeft" align="right" valign="top">static xiiInt32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d65/classxii_string_utils.htm#a8bb1ecbe39d0c2d0a4e58866dbe3ae66">CompareChars</a> (xiiUInt32 uiCharacter1, xiiUInt32 uiCharacter2)</td></tr>
<tr class="memdesc:a8bb1ecbe39d0c2d0a4e58866dbe3ae66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the two code points for equality.  <a href="../../df/d65/classxii_string_utils.htm#a8bb1ecbe39d0c2d0a4e58866dbe3ae66">More...</a><br /></td></tr>
<tr class="separator:a8bb1ecbe39d0c2d0a4e58866dbe3ae66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac28703e172339dc600a6757c4433e521"><td class="memItemLeft" align="right" valign="top">static xiiInt32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d65/classxii_string_utils.htm#ac28703e172339dc600a6757c4433e521">CompareChars</a> (const char *szUtf8Char1, const char *szUtf8Char2)</td></tr>
<tr class="memdesc:ac28703e172339dc600a6757c4433e521"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the first character of each utf8 string for equality.  <a href="../../df/d65/classxii_string_utils.htm#ac28703e172339dc600a6757c4433e521">More...</a><br /></td></tr>
<tr class="separator:ac28703e172339dc600a6757c4433e521"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf6005858a7226dbde41cb6141a21732"><td class="memItemLeft" align="right" valign="top">static xiiInt32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d65/classxii_string_utils.htm#abf6005858a7226dbde41cb6141a21732">CompareChars_NoCase</a> (xiiUInt32 uiCharacter1, xiiUInt32 uiCharacter2)</td></tr>
<tr class="memdesc:abf6005858a7226dbde41cb6141a21732"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the two code points for equality, case-insensitive.  <a href="../../df/d65/classxii_string_utils.htm#abf6005858a7226dbde41cb6141a21732">More...</a><br /></td></tr>
<tr class="separator:abf6005858a7226dbde41cb6141a21732"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5e5f43fd7d9f6cd7bb4524647560a3d"><td class="memItemLeft" align="right" valign="top">static xiiInt32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d65/classxii_string_utils.htm#af5e5f43fd7d9f6cd7bb4524647560a3d">CompareChars_NoCase</a> (const char *szUtf8Char1, const char *szUtf8Char2)</td></tr>
<tr class="memdesc:af5e5f43fd7d9f6cd7bb4524647560a3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the first character of each utf8 string for equality, case-insensitive.  <a href="../../df/d65/classxii_string_utils.htm#af5e5f43fd7d9f6cd7bb4524647560a3d">More...</a><br /></td></tr>
<tr class="separator:af5e5f43fd7d9f6cd7bb4524647560a3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39bb50553ad3fbca2c342abbca08fee5"><td class="memItemLeft" align="right" valign="top"><a id="a39bb50553ad3fbca2c342abbca08fee5"></a>
static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d65/classxii_string_utils.htm#a39bb50553ad3fbca2c342abbca08fee5">IsEqual</a> (const char *pString1, const char *pString2, const char *pString1End=<a class="el" href="../../de/d05/classxii_unicode_utils.htm#a660bf5a88b574b4be176332064e55fbe">xiiUnicodeUtils::GetMaxStringEnd</a>&lt; char &gt;(), const char *pString2End=<a class="el" href="../../de/d05/classxii_unicode_utils.htm#a660bf5a88b574b4be176332064e55fbe">xiiUnicodeUtils::GetMaxStringEnd</a>&lt; char &gt;())</td></tr>
<tr class="memdesc:a39bb50553ad3fbca2c342abbca08fee5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true, if the two given strings are identical (bitwise). <br /></td></tr>
<tr class="separator:a39bb50553ad3fbca2c342abbca08fee5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09ca4eeaceb90374a7e6af19b56eec25"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d65/classxii_string_utils.htm#a09ca4eeaceb90374a7e6af19b56eec25">IsEqualN</a> (const char *pString1, const char *pString2, xiiUInt32 uiCharsToCompare, const char *pString1End=<a class="el" href="../../de/d05/classxii_unicode_utils.htm#a660bf5a88b574b4be176332064e55fbe">xiiUnicodeUtils::GetMaxStringEnd</a>&lt; char &gt;(), const char *pString2End=<a class="el" href="../../de/d05/classxii_unicode_utils.htm#a660bf5a88b574b4be176332064e55fbe">xiiUnicodeUtils::GetMaxStringEnd</a>&lt; char &gt;())</td></tr>
<tr class="memdesc:a09ca4eeaceb90374a7e6af19b56eec25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true, if the two given strings are identical (bitwise) up to the n-th character.  <a href="../../df/d65/classxii_string_utils.htm#a09ca4eeaceb90374a7e6af19b56eec25">More...</a><br /></td></tr>
<tr class="separator:a09ca4eeaceb90374a7e6af19b56eec25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1dc8270bac3a9e25cc33ddbe2e54befd"><td class="memItemLeft" align="right" valign="top"><a id="a1dc8270bac3a9e25cc33ddbe2e54befd"></a>
static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d65/classxii_string_utils.htm#a1dc8270bac3a9e25cc33ddbe2e54befd">IsEqual_NoCase</a> (const char *pString1, const char *pString2, const char *pString1End=<a class="el" href="../../de/d05/classxii_unicode_utils.htm#a660bf5a88b574b4be176332064e55fbe">xiiUnicodeUtils::GetMaxStringEnd</a>&lt; char &gt;(), const char *pString2End=<a class="el" href="../../de/d05/classxii_unicode_utils.htm#a660bf5a88b574b4be176332064e55fbe">xiiUnicodeUtils::GetMaxStringEnd</a>&lt; char &gt;())</td></tr>
<tr class="memdesc:a1dc8270bac3a9e25cc33ddbe2e54befd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true, if the two given strings are identical (case-insensitive). <br /></td></tr>
<tr class="separator:a1dc8270bac3a9e25cc33ddbe2e54befd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53cc8803004fb5a140dc5ff761a450ee"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d65/classxii_string_utils.htm#a53cc8803004fb5a140dc5ff761a450ee">IsEqualN_NoCase</a> (const char *pString1, const char *pString2, xiiUInt32 uiCharsToCompare, const char *pString1End=<a class="el" href="../../de/d05/classxii_unicode_utils.htm#a660bf5a88b574b4be176332064e55fbe">xiiUnicodeUtils::GetMaxStringEnd</a>&lt; char &gt;(), const char *pString2End=<a class="el" href="../../de/d05/classxii_unicode_utils.htm#a660bf5a88b574b4be176332064e55fbe">xiiUnicodeUtils::GetMaxStringEnd</a>&lt; char &gt;())</td></tr>
<tr class="memdesc:a53cc8803004fb5a140dc5ff761a450ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true, if the two given strings are identical (case-insensitive) up to the n-th character.  <a href="../../df/d65/classxii_string_utils.htm#a53cc8803004fb5a140dc5ff761a450ee">More...</a><br /></td></tr>
<tr class="separator:a53cc8803004fb5a140dc5ff761a450ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7f20a820fd23caf6e017547438cc44d"><td class="memItemLeft" align="right" valign="top">static xiiInt32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d65/classxii_string_utils.htm#ac7f20a820fd23caf6e017547438cc44d">Compare</a> (const char *pString1, const char *pString2, const char *pString1End=<a class="el" href="../../de/d05/classxii_unicode_utils.htm#a660bf5a88b574b4be176332064e55fbe">xiiUnicodeUtils::GetMaxStringEnd</a>&lt; char &gt;(), const char *pString2End=<a class="el" href="../../de/d05/classxii_unicode_utils.htm#a660bf5a88b574b4be176332064e55fbe">xiiUnicodeUtils::GetMaxStringEnd</a>&lt; char &gt;())</td></tr>
<tr class="memdesc:ac7f20a820fd23caf6e017547438cc44d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two strings for equality.  <a href="../../df/d65/classxii_string_utils.htm#ac7f20a820fd23caf6e017547438cc44d">More...</a><br /></td></tr>
<tr class="separator:ac7f20a820fd23caf6e017547438cc44d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea128505cffde358c09361a71b9f8cb7"><td class="memItemLeft" align="right" valign="top">static xiiInt32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d65/classxii_string_utils.htm#aea128505cffde358c09361a71b9f8cb7">CompareN</a> (const char *pString1, const char *pString2, xiiUInt32 uiCharsToCompare, const char *pString1End=<a class="el" href="../../de/d05/classxii_unicode_utils.htm#a660bf5a88b574b4be176332064e55fbe">xiiUnicodeUtils::GetMaxStringEnd</a>&lt; char &gt;(), const char *pString2End=<a class="el" href="../../de/d05/classxii_unicode_utils.htm#a660bf5a88b574b4be176332064e55fbe">xiiUnicodeUtils::GetMaxStringEnd</a>&lt; char &gt;())</td></tr>
<tr class="memdesc:aea128505cffde358c09361a71b9f8cb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the first uiCharsToCompare characters of the two strings for equality.  <a href="../../df/d65/classxii_string_utils.htm#aea128505cffde358c09361a71b9f8cb7">More...</a><br /></td></tr>
<tr class="separator:aea128505cffde358c09361a71b9f8cb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5304362cc805b0ae9cc78b00e056521f"><td class="memItemLeft" align="right" valign="top">static xiiInt32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d65/classxii_string_utils.htm#a5304362cc805b0ae9cc78b00e056521f">Compare_NoCase</a> (const char *pString1, const char *pString2, const char *pString1End=<a class="el" href="../../de/d05/classxii_unicode_utils.htm#a660bf5a88b574b4be176332064e55fbe">xiiUnicodeUtils::GetMaxStringEnd</a>&lt; char &gt;(), const char *pString2End=<a class="el" href="../../de/d05/classxii_unicode_utils.htm#a660bf5a88b574b4be176332064e55fbe">xiiUnicodeUtils::GetMaxStringEnd</a>&lt; char &gt;())</td></tr>
<tr class="memdesc:a5304362cc805b0ae9cc78b00e056521f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two strings for equality, case-insensitive.  <a href="../../df/d65/classxii_string_utils.htm#a5304362cc805b0ae9cc78b00e056521f">More...</a><br /></td></tr>
<tr class="separator:a5304362cc805b0ae9cc78b00e056521f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80aa4948244d9ec7aec070ebd2ff5dd4"><td class="memItemLeft" align="right" valign="top">static xiiInt32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d65/classxii_string_utils.htm#a80aa4948244d9ec7aec070ebd2ff5dd4">CompareN_NoCase</a> (const char *pString1, const char *pString2, xiiUInt32 uiCharsToCompare, const char *pString1End=<a class="el" href="../../de/d05/classxii_unicode_utils.htm#a660bf5a88b574b4be176332064e55fbe">xiiUnicodeUtils::GetMaxStringEnd</a>&lt; char &gt;(), const char *pString2End=<a class="el" href="../../de/d05/classxii_unicode_utils.htm#a660bf5a88b574b4be176332064e55fbe">xiiUnicodeUtils::GetMaxStringEnd</a>&lt; char &gt;())</td></tr>
<tr class="memdesc:a80aa4948244d9ec7aec070ebd2ff5dd4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the first uiCharsToCompare characters of the two strings for equality, case-insensitive.  <a href="../../df/d65/classxii_string_utils.htm#a80aa4948244d9ec7aec070ebd2ff5dd4">More...</a><br /></td></tr>
<tr class="separator:a80aa4948244d9ec7aec070ebd2ff5dd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b5677b0dd4004f7ee6d20a31eee913c"><td class="memItemLeft" align="right" valign="top">static xiiInt32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d65/classxii_string_utils.htm#a2b5677b0dd4004f7ee6d20a31eee913c">snprintf</a> (char *szDst, xiiUInt32 uiDstSize, const char *szFormat,...)</td></tr>
<tr class="memdesc:a2b5677b0dd4004f7ee6d20a31eee913c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a formated string in szDst. uiDstSize defines how many bytes szDst can hold.  <a href="../../df/d65/classxii_string_utils.htm#a2b5677b0dd4004f7ee6d20a31eee913c">More...</a><br /></td></tr>
<tr class="separator:a2b5677b0dd4004f7ee6d20a31eee913c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0baa3e2dc382fae0d4bea6b91e10ab85"><td class="memItemLeft" align="right" valign="top">static xiiInt32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d65/classxii_string_utils.htm#a0baa3e2dc382fae0d4bea6b91e10ab85">vsnprintf</a> (char *szDst, xiiUInt32 uiDstSize, const char *szFormat, va_list szAp)</td></tr>
<tr class="memdesc:a0baa3e2dc382fae0d4bea6b91e10ab85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a formated string in szDst. uiDstSize defines how many bytes szDst can hold.  <a href="../../df/d65/classxii_string_utils.htm#a0baa3e2dc382fae0d4bea6b91e10ab85">More...</a><br /></td></tr>
<tr class="separator:a0baa3e2dc382fae0d4bea6b91e10ab85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb2538341d8cd31778bebdff947e2a59"><td class="memItemLeft" align="right" valign="top"><a id="afb2538341d8cd31778bebdff947e2a59"></a>
static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d65/classxii_string_utils.htm#afb2538341d8cd31778bebdff947e2a59">StartsWith</a> (const char *szString, const char *szStartsWith, const char *pStringEnd=<a class="el" href="../../de/d05/classxii_unicode_utils.htm#a660bf5a88b574b4be176332064e55fbe">xiiUnicodeUtils::GetMaxStringEnd</a>&lt; char &gt;(), const char *szStartsWithEnd=<a class="el" href="../../de/d05/classxii_unicode_utils.htm#a660bf5a88b574b4be176332064e55fbe">xiiUnicodeUtils::GetMaxStringEnd</a>&lt; char &gt;())</td></tr>
<tr class="memdesc:afb2538341d8cd31778bebdff947e2a59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if szString starts with the string given in szStartsWith. <br /></td></tr>
<tr class="separator:afb2538341d8cd31778bebdff947e2a59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad408d8e65febe01930e200bfd6f73dd"><td class="memItemLeft" align="right" valign="top"><a id="aad408d8e65febe01930e200bfd6f73dd"></a>
static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d65/classxii_string_utils.htm#aad408d8e65febe01930e200bfd6f73dd">StartsWith_NoCase</a> (const char *szString, const char *szStartsWith, const char *pStringEnd=<a class="el" href="../../de/d05/classxii_unicode_utils.htm#a660bf5a88b574b4be176332064e55fbe">xiiUnicodeUtils::GetMaxStringEnd</a>&lt; char &gt;(), const char *szStartsWithEnd=<a class="el" href="../../de/d05/classxii_unicode_utils.htm#a660bf5a88b574b4be176332064e55fbe">xiiUnicodeUtils::GetMaxStringEnd</a>&lt; char &gt;())</td></tr>
<tr class="memdesc:aad408d8e65febe01930e200bfd6f73dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if szString starts with the string given in szStartsWith. Ignores case. <br /></td></tr>
<tr class="separator:aad408d8e65febe01930e200bfd6f73dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45aff821fa89198e5f80f8b3754e35c8"><td class="memItemLeft" align="right" valign="top"><a id="a45aff821fa89198e5f80f8b3754e35c8"></a>
static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d65/classxii_string_utils.htm#a45aff821fa89198e5f80f8b3754e35c8">EndsWith</a> (const char *szString, const char *szEndsWith, const char *pStringEnd=<a class="el" href="../../de/d05/classxii_unicode_utils.htm#a660bf5a88b574b4be176332064e55fbe">xiiUnicodeUtils::GetMaxStringEnd</a>&lt; char &gt;(), const char *szEndsWithEnd=<a class="el" href="../../de/d05/classxii_unicode_utils.htm#a660bf5a88b574b4be176332064e55fbe">xiiUnicodeUtils::GetMaxStringEnd</a>&lt; char &gt;())</td></tr>
<tr class="memdesc:a45aff821fa89198e5f80f8b3754e35c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if szString ends with the string given in szEndsWith. <br /></td></tr>
<tr class="separator:a45aff821fa89198e5f80f8b3754e35c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af760d3c50a964ef80a077e3a6c5c24f1"><td class="memItemLeft" align="right" valign="top"><a id="af760d3c50a964ef80a077e3a6c5c24f1"></a>
static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d65/classxii_string_utils.htm#af760d3c50a964ef80a077e3a6c5c24f1">EndsWith_NoCase</a> (const char *szString, const char *szEndsWith, const char *pStringEnd=<a class="el" href="../../de/d05/classxii_unicode_utils.htm#a660bf5a88b574b4be176332064e55fbe">xiiUnicodeUtils::GetMaxStringEnd</a>&lt; char &gt;(), const char *szEndsWithEnd=<a class="el" href="../../de/d05/classxii_unicode_utils.htm#a660bf5a88b574b4be176332064e55fbe">xiiUnicodeUtils::GetMaxStringEnd</a>&lt; char &gt;())</td></tr>
<tr class="memdesc:af760d3c50a964ef80a077e3a6c5c24f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if szString ends with the string given in szEndsWith. Ignores case. <br /></td></tr>
<tr class="separator:af760d3c50a964ef80a077e3a6c5c24f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fa20e8fc3fdb98e0166ff5c1b6e83e8"><td class="memItemLeft" align="right" valign="top"><a id="a0fa20e8fc3fdb98e0166ff5c1b6e83e8"></a>
static const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d65/classxii_string_utils.htm#a0fa20e8fc3fdb98e0166ff5c1b6e83e8">FindSubString</a> (const char *szSource, const char *szStringToFind, const char *pSourceEnd=<a class="el" href="../../de/d05/classxii_unicode_utils.htm#a660bf5a88b574b4be176332064e55fbe">xiiUnicodeUtils::GetMaxStringEnd</a>&lt; char &gt;(), const char *szStringToFindEnd=<a class="el" href="../../de/d05/classxii_unicode_utils.htm#a660bf5a88b574b4be176332064e55fbe">xiiUnicodeUtils::GetMaxStringEnd</a>&lt; char &gt;())</td></tr>
<tr class="memdesc:a0fa20e8fc3fdb98e0166ff5c1b6e83e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches for the first occurrence of szStringToFind in szSource. <br /></td></tr>
<tr class="separator:a0fa20e8fc3fdb98e0166ff5c1b6e83e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1599c3f5fdec4d37af5595733e8a5cc5"><td class="memItemLeft" align="right" valign="top"><a id="a1599c3f5fdec4d37af5595733e8a5cc5"></a>
static const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d65/classxii_string_utils.htm#a1599c3f5fdec4d37af5595733e8a5cc5">FindSubString_NoCase</a> (const char *szSource, const char *szStringToFind, const char *pSourceEnd=<a class="el" href="../../de/d05/classxii_unicode_utils.htm#a660bf5a88b574b4be176332064e55fbe">xiiUnicodeUtils::GetMaxStringEnd</a>&lt; char &gt;(), const char *szStringToFindEnd=<a class="el" href="../../de/d05/classxii_unicode_utils.htm#a660bf5a88b574b4be176332064e55fbe">xiiUnicodeUtils::GetMaxStringEnd</a>&lt; char &gt;())</td></tr>
<tr class="memdesc:a1599c3f5fdec4d37af5595733e8a5cc5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches for the first occurrence of szStringToFind in szSource. Ignores case. <br /></td></tr>
<tr class="separator:a1599c3f5fdec4d37af5595733e8a5cc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b62f46028e90e2256247df03c4fcf80"><td class="memItemLeft" align="right" valign="top"><a id="a6b62f46028e90e2256247df03c4fcf80"></a>
static const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d65/classxii_string_utils.htm#a6b62f46028e90e2256247df03c4fcf80">FindLastSubString</a> (const char *szSource, const char *szStringToFind, const char *szStartSearchAt=nullptr, const char *pSourceEnd=<a class="el" href="../../de/d05/classxii_unicode_utils.htm#a660bf5a88b574b4be176332064e55fbe">xiiUnicodeUtils::GetMaxStringEnd</a>&lt; char &gt;(), const char *szStringToFindEnd=<a class="el" href="../../de/d05/classxii_unicode_utils.htm#a660bf5a88b574b4be176332064e55fbe">xiiUnicodeUtils::GetMaxStringEnd</a>&lt; char &gt;())</td></tr>
<tr class="memdesc:a6b62f46028e90e2256247df03c4fcf80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches for the last occurrence of szStringToFind in szSource before szStartSearchAt. <br /></td></tr>
<tr class="separator:a6b62f46028e90e2256247df03c4fcf80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e6aad91c372195c7e565e3f281b55f9"><td class="memItemLeft" align="right" valign="top"><a id="a8e6aad91c372195c7e565e3f281b55f9"></a>
static const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d65/classxii_string_utils.htm#a8e6aad91c372195c7e565e3f281b55f9">FindLastSubString_NoCase</a> (const char *szSource, const char *szStringToFind, const char *szStartSearchAt=nullptr, const char *pSourceEnd=<a class="el" href="../../de/d05/classxii_unicode_utils.htm#a660bf5a88b574b4be176332064e55fbe">xiiUnicodeUtils::GetMaxStringEnd</a>&lt; char &gt;(), const char *szStringToFindEnd=<a class="el" href="../../de/d05/classxii_unicode_utils.htm#a660bf5a88b574b4be176332064e55fbe">xiiUnicodeUtils::GetMaxStringEnd</a>&lt; char &gt;())</td></tr>
<tr class="memdesc:a8e6aad91c372195c7e565e3f281b55f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches for the last occurrence of szStringToFind in szSource before szStartSearchAt. Ignores case. <br /></td></tr>
<tr class="separator:a8e6aad91c372195c7e565e3f281b55f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94f0deead6e274cb780d4171c4b12bc7"><td class="memItemLeft" align="right" valign="top">static const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d65/classxii_string_utils.htm#a94f0deead6e274cb780d4171c4b12bc7">SkipCharacters</a> (const char *szString, <a class="el" href="../../df/d65/classxii_string_utils.htm#af474cd805cbd076c00d508adacd057bd">XII_CHARACTER_FILTER</a> skipCharacterCB, bool bAlwaysSkipFirst=false)</td></tr>
<tr class="memdesc:a94f0deead6e274cb780d4171c4b12bc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts at szString and advances to the next character for which SkipCharacterCB returns false;.  <a href="../../df/d65/classxii_string_utils.htm#a94f0deead6e274cb780d4171c4b12bc7">More...</a><br /></td></tr>
<tr class="separator:a94f0deead6e274cb780d4171c4b12bc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebb3fca85f4d33a25455bc92483cc944"><td class="memItemLeft" align="right" valign="top">static const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d65/classxii_string_utils.htm#aebb3fca85f4d33a25455bc92483cc944">FindWordEnd</a> (const char *szString, <a class="el" href="../../df/d65/classxii_string_utils.htm#af474cd805cbd076c00d508adacd057bd">XII_CHARACTER_FILTER</a> isDelimiterCB, bool bAlwaysSkipFirst=true)</td></tr>
<tr class="memdesc:aebb3fca85f4d33a25455bc92483cc944"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the position in szString at which <em>IsDelimiterCB</em> returns true.  <a href="../../df/d65/classxii_string_utils.htm#aebb3fca85f4d33a25455bc92483cc944">More...</a><br /></td></tr>
<tr class="separator:aebb3fca85f4d33a25455bc92483cc944"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace52b990b8af8413bc0622ffa96cc036"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d65/classxii_string_utils.htm#ace52b990b8af8413bc0622ffa96cc036">Trim</a> (const char *&amp;ref_pString, const char *&amp;ref_pStringEnd, const char *szTrimCharsStart, const char *szTrimCharsEnd)</td></tr>
<tr class="memdesc:ace52b990b8af8413bc0622ffa96cc036"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all characters at the start and end of the string that match the respective characters and updates the new start and end of the string.  <a href="../../df/d65/classxii_string_utils.htm#ace52b990b8af8413bc0622ffa96cc036">More...</a><br /></td></tr>
<tr class="separator:ace52b990b8af8413bc0622ffa96cc036"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89486e340fecb622b116e72c8dda0839"><td class="memItemLeft" align="right" valign="top"><a id="a89486e340fecb622b116e72c8dda0839"></a>
static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d65/classxii_string_utils.htm#a89486e340fecb622b116e72c8dda0839">IsWhiteSpace</a> (xiiUInt32 uiChar)</td></tr>
<tr class="memdesc:a89486e340fecb622b116e72c8dda0839"><td class="mdescLeft">&#160;</td><td class="mdescRight">A default word delimiter function that returns true for ' ' (space), '\r' (carriage return), '<br  />
' (newline), '\t' (tab) and '\v' (vertical tab) <br /></td></tr>
<tr class="separator:a89486e340fecb622b116e72c8dda0839"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b992efe61baf95db2aa651f6dbcd32d"><td class="memItemLeft" align="right" valign="top"><a id="a0b992efe61baf95db2aa651f6dbcd32d"></a>
static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d65/classxii_string_utils.htm#a0b992efe61baf95db2aa651f6dbcd32d">IsDecimalDigit</a> (xiiUInt32 uiChar)</td></tr>
<tr class="memdesc:a0b992efe61baf95db2aa651f6dbcd32d"><td class="mdescLeft">&#160;</td><td class="mdescRight">A decimal digit from 0..9. <br /></td></tr>
<tr class="separator:a0b992efe61baf95db2aa651f6dbcd32d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd4b68cdbb16d9dd943f8703cfd94337"><td class="memItemLeft" align="right" valign="top"><a id="abd4b68cdbb16d9dd943f8703cfd94337"></a>
static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d65/classxii_string_utils.htm#abd4b68cdbb16d9dd943f8703cfd94337">IsHexDigit</a> (xiiUInt32 uiChar)</td></tr>
<tr class="memdesc:abd4b68cdbb16d9dd943f8703cfd94337"><td class="mdescLeft">&#160;</td><td class="mdescRight">A hexadecimal digit from 0..F. <br /></td></tr>
<tr class="separator:abd4b68cdbb16d9dd943f8703cfd94337"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7639c495be8891d100bf6630d6a9c77c"><td class="memItemLeft" align="right" valign="top"><a id="a7639c495be8891d100bf6630d6a9c77c"></a>
static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d65/classxii_string_utils.htm#a7639c495be8891d100bf6630d6a9c77c">IsWordDelimiter_English</a> (xiiUInt32 uiChar)</td></tr>
<tr class="memdesc:a7639c495be8891d100bf6630d6a9c77c"><td class="mdescLeft">&#160;</td><td class="mdescRight">A default word delimiter function for English text. <br /></td></tr>
<tr class="separator:a7639c495be8891d100bf6630d6a9c77c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7191265da2e9a4bfd6fb98036c89ec67"><td class="memItemLeft" align="right" valign="top"><a id="a7191265da2e9a4bfd6fb98036c89ec67"></a>
static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d65/classxii_string_utils.htm#a7191265da2e9a4bfd6fb98036c89ec67">IsIdentifierDelimiter_C_Code</a> (xiiUInt32 uiChar)</td></tr>
<tr class="memdesc:a7191265da2e9a4bfd6fb98036c89ec67"><td class="mdescLeft">&#160;</td><td class="mdescRight">A default word delimiter function for identifiers in C code. <br /></td></tr>
<tr class="separator:a7191265da2e9a4bfd6fb98036c89ec67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25a1a2b433a1f85e25cb26735c2124e2"><td class="memItemLeft" align="right" valign="top"><a id="a25a1a2b433a1f85e25cb26735c2124e2"></a>
static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d65/classxii_string_utils.htm#a25a1a2b433a1f85e25cb26735c2124e2">IsValidIdentifierName</a> (const char *pString, const char *pStringEnd=<a class="el" href="../../de/d05/classxii_unicode_utils.htm#a660bf5a88b574b4be176332064e55fbe">xiiUnicodeUtils::GetMaxStringEnd</a>&lt; char &gt;())</td></tr>
<tr class="memdesc:a25a1a2b433a1f85e25cb26735c2124e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether the given string is a valid identifier name in C code, ie has no white-spaces, starts with a literal etc. <br /></td></tr>
<tr class="separator:a25a1a2b433a1f85e25cb26735c2124e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a071d71ef59f164b0c6039b7477c6c5ba"><td class="memItemLeft" align="right" valign="top"><a id="a071d71ef59f164b0c6039b7477c6c5ba"></a>
static const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d65/classxii_string_utils.htm#a071d71ef59f164b0c6039b7477c6c5ba">FindWholeWord</a> (const char *szString, const char *szSearchFor, <a class="el" href="../../df/d65/classxii_string_utils.htm#af474cd805cbd076c00d508adacd057bd">XII_CHARACTER_FILTER</a> isDelimiterCB, const char *pStringEnd=<a class="el" href="../../de/d05/classxii_unicode_utils.htm#a660bf5a88b574b4be176332064e55fbe">xiiUnicodeUtils::GetMaxStringEnd</a>&lt; char &gt;())</td></tr>
<tr class="memdesc:a071d71ef59f164b0c6039b7477c6c5ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches szString for the word szSearchFor. If IsDelimiterCB returns true for both characters in front and back of the word, the position is returned. Otherwise nullptr. <br /></td></tr>
<tr class="separator:a071d71ef59f164b0c6039b7477c6c5ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a914bb1b6d798187f4884d153f22d8946"><td class="memItemLeft" align="right" valign="top"><a id="a914bb1b6d798187f4884d153f22d8946"></a>
static const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d65/classxii_string_utils.htm#a914bb1b6d798187f4884d153f22d8946">FindWholeWord_NoCase</a> (const char *szString, const char *szSearchFor, <a class="el" href="../../df/d65/classxii_string_utils.htm#af474cd805cbd076c00d508adacd057bd">XII_CHARACTER_FILTER</a> isDelimiterCB, const char *pStringEnd=<a class="el" href="../../de/d05/classxii_unicode_utils.htm#a660bf5a88b574b4be176332064e55fbe">xiiUnicodeUtils::GetMaxStringEnd</a>&lt; char &gt;())</td></tr>
<tr class="memdesc:a914bb1b6d798187f4884d153f22d8946"><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches szString for the word szSearchFor. If IsDelimiterCB returns true for both characters in front and back of the word, the position is returned. Otherwise nullptr. Ignores case. <br /></td></tr>
<tr class="separator:a914bb1b6d798187f4884d153f22d8946"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1eb465543c949b432db27bf8ab6d8a6"><td class="memItemLeft" align="right" valign="top"><a id="ae1eb465543c949b432db27bf8ab6d8a6"></a>
static <a class="el" href="../../dd/dad/structxii_result.htm">xiiResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d65/classxii_string_utils.htm#ae1eb465543c949b432db27bf8ab6d8a6">FindUIntAtTheEnd</a> (const char *szString, xiiUInt32 &amp;out_uiValue, xiiUInt32 *pStringLengthBeforeUInt=nullptr)</td></tr>
<tr class="memdesc:ae1eb465543c949b432db27bf8ab6d8a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the given szString ends with an unsigned integer (e.g. "MyString123"). If pStringLengthBeforeUInt is non-null the string length up to the first digit is stored. Returns XII_SUCCESS if there is a value at the end of string, XII_FAILURE otherwise. <br /></td></tr>
<tr class="separator:ae1eb465543c949b432db27bf8ab6d8a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a0b74f61d0e82ea0b3e9cd58ce4cfa2"><td class="memItemLeft" align="right" valign="top"><a id="a5a0b74f61d0e82ea0b3e9cd58ce4cfa2"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d65/classxii_string_utils.htm#a5a0b74f61d0e82ea0b3e9cd58ce4cfa2">OutputFormattedInt</a> (char *szOutputBuffer, xiiUInt32 uiBufferSize, xiiUInt32 &amp;ref_uiWritePos, xiiInt64 value, xiiUInt8 uiWidth, bool bPadZeros, xiiUInt8 uiBase)</td></tr>
<tr class="memdesc:a5a0b74f61d0e82ea0b3e9cd58ce4cfa2"><td class="mdescLeft">&#160;</td><td class="mdescRight">[internal] Prefer to use snprintf. <br /></td></tr>
<tr class="separator:a5a0b74f61d0e82ea0b3e9cd58ce4cfa2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a542dbaf977c7e0eaaaf2767f0a643113"><td class="memItemLeft" align="right" valign="top"><a id="a542dbaf977c7e0eaaaf2767f0a643113"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d65/classxii_string_utils.htm#a542dbaf977c7e0eaaaf2767f0a643113">OutputFormattedUInt</a> (char *szOutputBuffer, xiiUInt32 uiBufferSize, xiiUInt32 &amp;ref_uiWritePos, xiiUInt64 value, xiiUInt8 uiWidth, bool bPadZeros, xiiUInt8 uiBase, bool bUpperCase)</td></tr>
<tr class="memdesc:a542dbaf977c7e0eaaaf2767f0a643113"><td class="mdescLeft">&#160;</td><td class="mdescRight">[internal] Prefer to use snprintf. <br /></td></tr>
<tr class="separator:a542dbaf977c7e0eaaaf2767f0a643113"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa09ca69a3e92c9f37131f49406c2ae7f"><td class="memItemLeft" align="right" valign="top"><a id="aa09ca69a3e92c9f37131f49406c2ae7f"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d65/classxii_string_utils.htm#aa09ca69a3e92c9f37131f49406c2ae7f">OutputFormattedFloat</a> (char *szOutputBuffer, xiiUInt32 uiBufferSize, xiiUInt32 &amp;ref_uiWritePos, double value, xiiUInt8 uiWidth, bool bPadZeros, xiiInt8 iPrecision, bool bScientific, bool bRemoveTrailingZeroes=false)</td></tr>
<tr class="memdesc:aa09ca69a3e92c9f37131f49406c2ae7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">[internal] Prefer to use snprintf. <br /></td></tr>
<tr class="separator:aa09ca69a3e92c9f37131f49406c2ae7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f17d12ee53866f542591c778a20665f"><td class="memItemLeft" align="right" valign="top"><a id="a7f17d12ee53866f542591c778a20665f"></a>
static XII_ALWAYS_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><b>AddUsedStringLength</b> (xiiUInt32)</td></tr>
<tr class="separator:a7f17d12ee53866f542591c778a20665f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18bde206e2f12c483879fd73ee40dde8"><td class="memItemLeft" align="right" valign="top"><a id="a18bde206e2f12c483879fd73ee40dde8"></a>
static XII_ALWAYS_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><b>PrintStringLengthStatistics</b> ()</td></tr>
<tr class="separator:a18bde206e2f12c483879fd73ee40dde8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Helper functions to work with UTF-8 strings (which include pure ASCII strings) </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="ac7f20a820fd23caf6e017547438cc44d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7f20a820fd23caf6e017547438cc44d">&#9670;&nbsp;</a></span>Compare()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">xiiInt32 xiiStringUtils::Compare </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pString1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pString2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pString1End</em> = <code><a class="el" href="../../de/d05/classxii_unicode_utils.htm#a660bf5a88b574b4be176332064e55fbe">xiiUnicodeUtils::GetMaxStringEnd</a>&lt;char&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pString2End</em> = <code><a class="el" href="../../de/d05/classxii_unicode_utils.htm#a660bf5a88b574b4be176332064e55fbe">xiiUnicodeUtils::GetMaxStringEnd</a>&lt;char&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares two strings for equality. </p>
<p>Returns a negative number if the pString1 is 'smaller' or shorter than pString2. Returns a positive number, if pString1 is 'larger' or longer than pString1. Returns 0 for equal strings. Works with UTF-8 strings as well. </p>

</div>
</div>
<a id="a5304362cc805b0ae9cc78b00e056521f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5304362cc805b0ae9cc78b00e056521f">&#9670;&nbsp;</a></span>Compare_NoCase()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">xiiInt32 xiiStringUtils::Compare_NoCase </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pString1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pString2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pString1End</em> = <code><a class="el" href="../../de/d05/classxii_unicode_utils.htm#a660bf5a88b574b4be176332064e55fbe">xiiUnicodeUtils::GetMaxStringEnd</a>&lt;char&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pString2End</em> = <code><a class="el" href="../../de/d05/classxii_unicode_utils.htm#a660bf5a88b574b4be176332064e55fbe">xiiUnicodeUtils::GetMaxStringEnd</a>&lt;char&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares two strings for equality, case-insensitive. </p>
<p>Returns a negative number if the pString1 is 'smaller' or shorter than pString2. Returns a positive number, if pString1 is 'larger' or longer than pString1. Returns 0 for equal strings. Works with UTF-8 strings as well. </p>

</div>
</div>
<a id="ac28703e172339dc600a6757c4433e521"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac28703e172339dc600a6757c4433e521">&#9670;&nbsp;</a></span>CompareChars() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">xiiInt32 xiiStringUtils::CompareChars </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>szUtf8Char1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>szUtf8Char2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares the first character of each utf8 string for equality. </p>
<p>Returns a negative number, if szUtf8Char1 is smaller than szUtf8Char2. Returns a positive number, if szUtf8Char1 is larger than szUtf8Char2. Returns 0 if both are equal. </p>

</div>
</div>
<a id="a8bb1ecbe39d0c2d0a4e58866dbe3ae66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8bb1ecbe39d0c2d0a4e58866dbe3ae66">&#9670;&nbsp;</a></span>CompareChars() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">XII_ALWAYS_INLINE xiiInt32 xiiStringUtils::CompareChars </td>
          <td>(</td>
          <td class="paramtype">xiiUInt32&#160;</td>
          <td class="paramname"><em>uiCharacter1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">xiiUInt32&#160;</td>
          <td class="paramname"><em>uiCharacter2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares the two code points for equality. </p>
<p>Returns a negative number, if uiCharacter1 is smaller than uiCharacter2. Returns a positive number, if uiCharacter1 is larger than uiCharacter2. Returns 0 if both are equal. </p>

</div>
</div>
<a id="af5e5f43fd7d9f6cd7bb4524647560a3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5e5f43fd7d9f6cd7bb4524647560a3d">&#9670;&nbsp;</a></span>CompareChars_NoCase() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">xiiInt32 xiiStringUtils::CompareChars_NoCase </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>szUtf8Char1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>szUtf8Char2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares the first character of each utf8 string for equality, case-insensitive. </p>
<p>Returns a negative number, if szUtf8Char1 is smaller than szUtf8Char2. Returns a positive number, if szUtf8Char1 is larger than szUtf8Char2. Returns 0 if both are equal. </p>

</div>
</div>
<a id="abf6005858a7226dbde41cb6141a21732"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf6005858a7226dbde41cb6141a21732">&#9670;&nbsp;</a></span>CompareChars_NoCase() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">xiiInt32 xiiStringUtils::CompareChars_NoCase </td>
          <td>(</td>
          <td class="paramtype">xiiUInt32&#160;</td>
          <td class="paramname"><em>uiCharacter1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">xiiUInt32&#160;</td>
          <td class="paramname"><em>uiCharacter2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares the two code points for equality, case-insensitive. </p>
<p>Returns a negative number, if uiCharacter1 is smaller than uiCharacter2. Returns a positive number, if uiCharacter1 is larger than uiCharacter2. Returns 0 if both are equal. </p>

</div>
</div>
<a id="aea128505cffde358c09361a71b9f8cb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea128505cffde358c09361a71b9f8cb7">&#9670;&nbsp;</a></span>CompareN()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">xiiInt32 xiiStringUtils::CompareN </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pString1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pString2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">xiiUInt32&#160;</td>
          <td class="paramname"><em>uiCharsToCompare</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pString1End</em> = <code><a class="el" href="../../de/d05/classxii_unicode_utils.htm#a660bf5a88b574b4be176332064e55fbe">xiiUnicodeUtils::GetMaxStringEnd</a>&lt;char&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pString2End</em> = <code><a class="el" href="../../de/d05/classxii_unicode_utils.htm#a660bf5a88b574b4be176332064e55fbe">xiiUnicodeUtils::GetMaxStringEnd</a>&lt;char&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares the first uiCharsToCompare characters of the two strings for equality. </p>
<p>Returns a negative number if the pString1 is 'smaller' or shorter than pString2. Returns a positive number, if pString1 is 'larger' or longer than pString1. Returns 0 for equal strings. Works with UTF-8 strings as well. </p>

</div>
</div>
<a id="a80aa4948244d9ec7aec070ebd2ff5dd4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80aa4948244d9ec7aec070ebd2ff5dd4">&#9670;&nbsp;</a></span>CompareN_NoCase()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">xiiInt32 xiiStringUtils::CompareN_NoCase </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pString1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pString2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">xiiUInt32&#160;</td>
          <td class="paramname"><em>uiCharsToCompare</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pString1End</em> = <code><a class="el" href="../../de/d05/classxii_unicode_utils.htm#a660bf5a88b574b4be176332064e55fbe">xiiUnicodeUtils::GetMaxStringEnd</a>&lt;char&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pString2End</em> = <code><a class="el" href="../../de/d05/classxii_unicode_utils.htm#a660bf5a88b574b4be176332064e55fbe">xiiUnicodeUtils::GetMaxStringEnd</a>&lt;char&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares the first uiCharsToCompare characters of the two strings for equality, case-insensitive. </p>
<p>Returns a negative number if the pString1 is 'smaller' or shorter than pString2. Returns a positive number, if pString1 is 'larger' or longer than pString1. Returns 0 for equal strings. Works with UTF-8 strings as well. </p>

</div>
</div>
<a id="a44289a040ea3318f4a776e5d8035cf5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44289a040ea3318f4a776e5d8035cf5b">&#9670;&nbsp;</a></span>Copy()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">xiiUInt32 xiiStringUtils::Copy </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>szDest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">xiiUInt32&#160;</td>
          <td class="paramname"><em>uiDstSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>szSource</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pSourceEnd</em> = <code><a class="el" href="../../de/d05/classxii_unicode_utils.htm#a660bf5a88b574b4be176332064e55fbe">xiiUnicodeUtils::GetMaxStringEnd</a>&lt;char&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies the string from szSource into the given buffer, which can hold at least uiDstSize bytes. </p>
<p>The string will always be \0 terminated. Multi-byte UTF-8 characters will only be copied, if they can fit completely into szDest. I.e. they will be truncated at a character boundary. Returns the number of bytes that were copied into szDest, excluding the terminating \0 </p>

</div>
</div>
<a id="a21f81d8eeb22d68b218eaf0518d4a324"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21f81d8eeb22d68b218eaf0518d4a324">&#9670;&nbsp;</a></span>CopyN()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">xiiUInt32 xiiStringUtils::CopyN </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>szDest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">xiiUInt32&#160;</td>
          <td class="paramname"><em>uiDstSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>szSource</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">xiiUInt32&#160;</td>
          <td class="paramname"><em>uiCharsToCopy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pSourceEnd</em> = <code><a class="el" href="../../de/d05/classxii_unicode_utils.htm#a660bf5a88b574b4be176332064e55fbe">xiiUnicodeUtils::GetMaxStringEnd</a>&lt;char&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies up to uiCharsToCopy characters into the given buffer, which can hold at least uiDstSize bytes. </p>
<p>The string will always be \0 terminated. Multi-byte UTF-8 characters will only be copied, if they can fit completely into szDest. I.e. they will be truncated at a character boundary. Returns the number of bytes that were copied into szDest, excluding the terminating \0 </p>

</div>
</div>
<a id="aebb3fca85f4d33a25455bc92483cc944"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebb3fca85f4d33a25455bc92483cc944">&#9670;&nbsp;</a></span>FindWordEnd()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char * xiiStringUtils::FindWordEnd </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>szString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../df/d65/classxii_string_utils.htm#af474cd805cbd076c00d508adacd057bd">XII_CHARACTER_FILTER</a>&#160;</td>
          <td class="paramname"><em>isDelimiterCB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bAlwaysSkipFirst</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the position in szString at which <em>IsDelimiterCB</em> returns true. </p>
<p>This is basically the inverse of SkipCharacters. SkipCharacters advances over all characters that fulfill the filter, FindWordEnd advances over all characters that do not fulfill it. </p>

</div>
</div>
<a id="af9de18eab321e420a8c5e42fbbe4703d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9de18eab321e420a8c5e42fbbe4703d">&#9670;&nbsp;</a></span>GetStringElementCount() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr xiiUInt32 xiiStringUtils::GetStringElementCount </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>pString</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of elements of type T that the string contains, until it hits an element that is zero OR until it hits the end pointer. </p>
<p>Equal to the string length, if used with pure ASCII strings. Equal to the amount of bytes in a string, if used on non-ASCII (i.e. UTF-8) strings. Equal to the number of characters in a string, if used with UTF-32 strings. </p>

</div>
</div>
<a id="a66dfed366a3dea54e5244aebbb086d77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66dfed366a3dea54e5244aebbb086d77">&#9670;&nbsp;</a></span>GetStringElementCount() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">xiiUInt32 xiiStringUtils::GetStringElementCount </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>pString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>pStringEnd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of elements of type T that the string contains, until it hits an element that is zero OR until it hits the end pointer. </p>
<p>Equal to the string length, if used with pure ASCII strings. Equal to the amount of bytes in a string, if used on non-ASCII (i.e. UTF-8) strings. Equal to the number of characters in a string, if used with UTF-32 strings. </p>

</div>
</div>
<a id="a09ca4eeaceb90374a7e6af19b56eec25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09ca4eeaceb90374a7e6af19b56eec25">&#9670;&nbsp;</a></span>IsEqualN()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">XII_ALWAYS_INLINE bool xiiStringUtils::IsEqualN </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pString1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pString2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">xiiUInt32&#160;</td>
          <td class="paramname"><em>uiCharsToCompare</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pString1End</em> = <code><a class="el" href="../../de/d05/classxii_unicode_utils.htm#a660bf5a88b574b4be176332064e55fbe">xiiUnicodeUtils::GetMaxStringEnd</a>&lt;char&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pString2End</em> = <code><a class="el" href="../../de/d05/classxii_unicode_utils.htm#a660bf5a88b574b4be176332064e55fbe">xiiUnicodeUtils::GetMaxStringEnd</a>&lt;char&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true, if the two given strings are identical (bitwise) up to the n-th character. </p>
<p>This function will handle UTF-8 strings properly. </p>

</div>
</div>
<a id="a53cc8803004fb5a140dc5ff761a450ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53cc8803004fb5a140dc5ff761a450ee">&#9670;&nbsp;</a></span>IsEqualN_NoCase()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">XII_ALWAYS_INLINE bool xiiStringUtils::IsEqualN_NoCase </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pString1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pString2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">xiiUInt32&#160;</td>
          <td class="paramname"><em>uiCharsToCompare</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pString1End</em> = <code><a class="el" href="../../de/d05/classxii_unicode_utils.htm#a660bf5a88b574b4be176332064e55fbe">xiiUnicodeUtils::GetMaxStringEnd</a>&lt;char&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pString2End</em> = <code><a class="el" href="../../de/d05/classxii_unicode_utils.htm#a660bf5a88b574b4be176332064e55fbe">xiiUnicodeUtils::GetMaxStringEnd</a>&lt;char&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true, if the two given strings are identical (case-insensitive) up to the n-th character. </p>
<p>This function will handle UTF-8 strings properly. </p>

</div>
</div>
<a id="a94f0deead6e274cb780d4171c4b12bc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94f0deead6e274cb780d4171c4b12bc7">&#9670;&nbsp;</a></span>SkipCharacters()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char * xiiStringUtils::SkipCharacters </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>szString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../df/d65/classxii_string_utils.htm#af474cd805cbd076c00d508adacd057bd">XII_CHARACTER_FILTER</a>&#160;</td>
          <td class="paramname"><em>skipCharacterCB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bAlwaysSkipFirst</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Starts at szString and advances to the next character for which SkipCharacterCB returns false;. </p>
<p>If <em>bAlwaysSkipFirst</em> is false and szString points to a character that does not fulfill the filter, this function will return immediately and nothing will change. If <em>bAlwaysSkipFirst</em> is true, the first character will always be skipped, regardless what it is (unless it is the zero terminator). The latter is useful to skip an entire word and get to the next word in a string.<br  />
 </p>

</div>
</div>
<a id="a2b5677b0dd4004f7ee6d20a31eee913c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b5677b0dd4004f7ee6d20a31eee913c">&#9670;&nbsp;</a></span>snprintf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int xiiStringUtils::snprintf </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>szDst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">xiiUInt32&#160;</td>
          <td class="paramname"><em>uiDstSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>szFormat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a formated string in szDst. uiDstSize defines how many bytes szDst can hold. </p>
<p>Returns the number of bytes that would have been required to output the entire string (excluding the 0 terminator).<br  />
Returns -1 if an error occurred. In this case it might also write a more detailed error message to the destination string itself. szDst may be nullptr.<br  />
uiDstSize may be zero.<br  />
This can be used to query how much storage is required, then allocate it and call snprintf again to fill it.<br  />
Formatting works exactly like printf, except that it additionally supports outputting binary with the 'b' modifier and it will output float NaN and Infinity as proper text. </p>

</div>
</div>
<a id="a824224a0b78ee435790cc8d40bd9a777"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a824224a0b78ee435790cc8d40bd9a777">&#9670;&nbsp;</a></span>ToLowerString()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">xiiUInt32 xiiStringUtils::ToLowerString </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>szString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pStringEnd</em> = <code><a class="el" href="../../de/d05/classxii_unicode_utils.htm#a660bf5a88b574b4be176332064e55fbe">xiiUnicodeUtils::GetMaxStringEnd</a>&lt;char&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts a (UTF-8) string in-place to lower case. </p>
<p>Returns the new string length in bytes (it might shrink, but never grow), excluding the \0 terminator. </p>

</div>
</div>
<a id="ad1629e8f94dd9f959339891cb0d91b2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1629e8f94dd9f959339891cb0d91b2f">&#9670;&nbsp;</a></span>ToUpperString()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">xiiUInt32 xiiStringUtils::ToUpperString </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>szString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pStringEnd</em> = <code><a class="el" href="../../de/d05/classxii_unicode_utils.htm#a660bf5a88b574b4be176332064e55fbe">xiiUnicodeUtils::GetMaxStringEnd</a>&lt;char&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts a (UTF-8) string in-place to upper case. </p>
<p>Returns the new string length in bytes (it might shrink, but never grow), excluding the \0 terminator. </p>

</div>
</div>
<a id="ace52b990b8af8413bc0622ffa96cc036"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace52b990b8af8413bc0622ffa96cc036">&#9670;&nbsp;</a></span>Trim()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void xiiStringUtils::Trim </td>
          <td>(</td>
          <td class="paramtype">const char *&amp;&#160;</td>
          <td class="paramname"><em>ref_pString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&amp;&#160;</td>
          <td class="paramname"><em>ref_pStringEnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>szTrimCharsStart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>szTrimCharsEnd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes all characters at the start and end of the string that match the respective characters and updates the new start and end of the string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pString</td><td>The string to trim. </td></tr>
    <tr><td class="paramname">pStringEnd</td><td>The end pointer into pString, either the end pointer for the not zero terminated string or xiiMaxStringEnd for zero terminated ones.</td></tr>
    <tr><td class="paramname">szTrimCharsStart</td><td>A string compromised of characters to trim from the start of the string.</td></tr>
    <tr><td class="paramname">szTrimCharsEnd</td><td>A string compromised of characters to trim from the end of the string. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0baa3e2dc382fae0d4bea6b91e10ab85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0baa3e2dc382fae0d4bea6b91e10ab85">&#9670;&nbsp;</a></span>vsnprintf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int xiiStringUtils::vsnprintf </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>szDst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">xiiUInt32&#160;</td>
          <td class="paramname"><em>uiDstSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>szFormat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">va_list&#160;</td>
          <td class="paramname"><em>szAp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a formated string in szDst. uiDstSize defines how many bytes szDst can hold. </p>
<p>Returns the number of bytes that would have been required to output the entire string (excluding the 0 terminator).<br  />
Returns -1 if an error occurred. In this case it might also write a more detailed error message to the destination string itself. szDst may be nullptr.<br  />
uiDstSize may be zero.<br  />
This can be used to query how much storage is required, then allocate it and call snprintf again to fill it.<br  />
Formatting works exactly like printf, except that it additionally supports outputting binary with the 'b' modifier and it will output float NaN and Infinity as proper text. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>/home/runner/work/XII/XII/Source/Engine/Foundation/Strings/<a class="el" href="../../de/dde/_string_utils_8h_source.htm">StringUtils.h</a></li>
<li>/home/runner/work/XII/XII/Source/Engine/Foundation/Strings/Implementation/snprintf.cpp</li>
<li>/home/runner/work/XII/XII/Source/Engine/Foundation/Strings/Implementation/StringUtils.cpp</li>
<li>/home/runner/work/XII/XII/Source/Engine/Foundation/Strings/Implementation/<a class="el" href="../../d4/d13/_string_utils__inl_8h_source.htm">StringUtils_inl.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="../../df/d65/classxii_string_utils.htm">xiiStringUtils</a></li>
    <li class="footer">Generated on Sun Dec 10 2023 03:58:39 for XIIEngine by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="../../doxygen.png" alt="doxygen"/></a> 1.8.17 </li>
  </ul>
</div>
</body>
</html>
